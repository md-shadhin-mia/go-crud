{
	// Place your go-crud workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
"Go Gin Controller": {
		"prefix": "gogincontroller",
		"body": [
			
			"type ${1:User}Controller struct {",
			"\tDB *gorm.DB",
			"}",
			"",
			"// New${1:User}Controller creates a new instance of ${1:User}Controller with dependencies injected.",
			"func New${1:User}Controller(db *gorm.DB) *${1:User}Controller {",
			"\treturn &${1:User}Controller{DB: db}",
			"}",
			"",
			"// @Summary Get all ${2:users}",
			"// @Description Get all ${2:users}",
			"// @Tags ${1:User}",
			"// @Accept json",
			"// @Produce json",
			"// @Success 200 {array} models.${1:User}",
			"// @Router /users [get]",
			"func (u *${1:User}Controller) GetAll(c *gin.Context) {",
			"\tvar ${2:users} []models.${1:User}",
			"\tif err := u.DB.Find(&${2:users}).Error; err != nil {",
			"\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch ${2:users}\"})",
			"\t\treturn",
			"\t}",
			"\tc.JSON(http.StatusOK, ${2:users})",
			"}",
			"",
			"// @Summary Get a ${3:user} by id",
			"// @Description Get a ${3:user} by id",
			"// @Tags ${1:User}",
			"// @Accept json",
			"// @Produce json",
			"// @Param id path string true \"${1:User} ID\"",
			"// @Success 200 {object} models.${1:User}",
			"// @Router /users/{id} [get]",
			"func (u *${1:User}Controller) GetById(c *gin.Context) {",
			"\tid := c.Param(\"id\")",
			"\tvar ${3:user} models.${1:User}",
			"\tif err := u.DB.First(&${3:user}, id).Error; err != nil {",
			"\t\tif err == gorm.ErrRecordNotFound {",
			"\t\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"${1:User} not found\"})",
			"\t\t} else {",
			"\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch ${3:user}\"})",
			"\t\t}",
			"\t\treturn",
			"\t}",
			"\tc.JSON(http.StatusOK, ${3:user})",
			"}",
			"",
			"// @Summary Create a ${3:user}",
			"// @Description Create a ${3:user}",
			"// @Tags ${1:User}",
			"// @Accept json",
			"// @Produce json",
			"// @Param ${3:user} body models.${1:User} true \"${1:User} data\"",
			"// @Success 201 {object} models.${1:User}",
			"// @Router /users [post]",
			"func (u *${1:User}Controller) Create(c *gin.Context) {",
			"\tvar input models.${1:User}",
			"\tif err := c.ShouldBindJSON(&input); err != nil {",
			"\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})",
			"\t\treturn",
			"\t}",
			"",
			"\tif err := u.DB.Create(&input).Error; err != nil {",
			"\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create ${3:user}\"})",
			"\t\treturn",
			"\t}",
			"",
			"\tc.JSON(http.StatusCreated, input)",
			"}",
			"",
			"// @Summary Update a ${3:user} by id",
			"// @Description Update a ${3:user} by id",
			"// @Tags ${1:User}",
			"// @Accept json",
			"// @Produce json",
			"// @Param id path string true \"${1:User} ID\"",
			"// @Param ${3:user} body models.${1:User} true \"${1:User} data\"",
			"// @Success 200 {object} models.${1:User}",
			"// @Router /users/{id} [put]",
			"func (u *${1:User}Controller) Update(c *gin.Context) {",
			"\tid := c.Param(\"id\")",
			"\tvar ${3:user} models.${1:User}",
			"\tif err := u.DB.First(&${3:user}, id).Error; err != nil {",
			"\t\tif err == gorm.ErrRecordNotFound {",
			"\t\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"${1:User} not found\"})",
			"\t\t} else {",
			"\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch ${3:user}\"})",
			"\t\t}",
			"\t\treturn",
			"\t}",
			"",
			"\tif err := c.ShouldBindJSON(&${3:user}); err != nil {",
			"\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})",
			"\t\treturn",
			"\t}",
			"",
			"\tif err := u.DB.Save(&${3:user}).Error; err != nil {",
			"\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to update ${3:user}\"})",
			"\t\treturn",
			"\t}",
			"",
			"\tc.JSON(http.StatusOK, ${3:user})",
			"}",
			"",
			"// @Summary Delete a ${3:user} by id",
			"// @Description Delete a ${3:user} by id",
			"// @Tags ${1:User}",
			"// @Accept json",
			"// @Produce json",
			"// @Param id path string true \"${1:User} ID\"",
			"// @Success 200",
			"// @Router /users/{id} [delete]",
			"func (u *${1:User}Controller) Delete(c *gin.Context) {",
			"\tid := c.Param(\"id\")",
			"\tvar ${3:user} models.${1:User}",
			"\tif err := u.DB.First(&${3:user}, id).Error; err != nil {",
			"\t\tif err == gorm.ErrRecordNotFound {",
			"\t\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"${1:User} not found\"})",
			"\t\t} else {",
			"\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch ${3:user}\"})",
			"\t\t}",
			"\t\treturn",
			"\t}",
			"",
			"\tif err := u.DB.Delete(&${3:user}).Error; err != nil {",
			"\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to delete ${3:user}\"})",
			"\t\treturn",
			"\t}",
			"",
			"\tc.JSON(http.StatusOK, gin.H{\"message\": \"${1:User} deleted\"})",
			"}"
		],
		"description": "Generate a Go Gin controller with CRUD operations and annotations"
	}
}